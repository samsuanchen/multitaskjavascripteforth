code immediate function () {	// 定義 指令 immediate
  lastWord.immediate=1		// 使 最後定義的指令 在高階編譯狀態 能執行
} end-code
code compileOnly function () {	// 定義 指令 compileOnly
  lastWord.compileOnly=1	// 使 最後定義的指令 在高階編譯狀態 才執行
} end-code
code // function () { var n,t	// 定義 指令 // (雙斜線) 忽略源碼字串到 列尾
  iTib += (n= (t=tib.substr(iTib)).indexOf('\n') )>=0 ? n : t.length
} end-code immediate		// 使 雙斜線 指令 在高階編譯狀態 能執行
code time_bgn function(){
  time0=new Date()
  print('\n'+time0+'\nset time_bgn as 0')
} end-code
code time_end function(){
  var t=new Date(), d=t-time0
  print('\n'+t+'\nget time_end at '+d)
} end-code
code start function (){ 
  while(z=findWord( nxtTkn() )) {
    var w=zWord(z)
    if (w.src) {
       rStkLen=rStk.length,rStk.push(ip),ip=w.xt
       var task={rStk:rStk,rStkLen:rStkLen,dStk:dStk,z:z,ip:ip}
       var t=new Date(), d=t-time0
       print('\n'+digits(d,6)+' set to start '+z+' '+w.name+' '+ip)
       setTimeout(function(){
         resumeTask(task)
       },1)
    } else
       abort(z+' '+w.name+' not high level to start')
  }
} end-code 
code (ms) function(){
  var n=dStk.pop(), z=compiledCode[ip++]
  var task={rStk:rStk,rStkLen:rStkLen,dStk:dStk,z:z,ip:ip}
  var t=new Date(), d=t-time0
  print('\n'+digits(d,6)+' set to resumeTask '+
     zWord(z).name+' '+ip+' after '+n+' ms')
  var x='(function(){resumeTask(task)})'
  x=eval(x), setTimeout(x,n), waiting=1
} end-code compileOnly
code ms function(){
  if (compiling) {
     compileCode('(ms)',current+','+vocs[current].words.length); return
  }
  var n=dStk.pop(), t=new Date(), d=t-time0
  print('\n'+digits(d,6)+' set to resumeExec after '+n+' ms')
  setTimeout(resumeExec,n), waiting=1
} end-code immediate
code r@ function () {
  dStk.push(rStk[rStk.length-1])
} end-code
code (for) function () {
  rStk.push(dStk.pop())
} end-code
code for function () {
  compileCode('(for)'), dStk.push(compiledCode.length)
} end-code compileOnly immediate
code (next) function () {
  var rTop=--rStk[rStk.length-1]
  if (0>rTop) {
    ip++, rStk.length--
    return
  }
  ip=compiledCode[ip]
} end-code compileOnly
code next function () {
  compileCode('(next)',dStk.pop())
} end-code compileOnly immediate
code : function () { // 定義 指令 : ( <指令名稱> -- ) 開始 高階指令的定義
  src		= ''			// 高階指令 源碼
  hSrc		= iTib-2		// 高階指令 源碼字串起點
  hName		= nxtTkn()		// 高階指令 名稱
  hXt		= compiledCode.length 	// 高階指令 編碼起點
  compiling	= 1			// 高階指令 編譯狀態 進入
} end-code
code compileOnly function () { // 定義 指令 compileOnly ( -- )
  lastWord.compileOnly=1		// 使 最後定義指令 高階編譯狀態 才編碼
} end-code
code ret function () { // 定義 指令 ret ( -- ) 結束被呼叫的 高階指令
  ip=rStk.pop()		// 從 return stack 取出 ip
} end-code compileOnly	// 使 ret 在高階編譯狀態 才編碼
code doLit function () { // 定義 指令 doLit ( -- n ) 將 隨後編碼 n 放上堆疊
  var n=compiledCode[ip++]	// 取 ip 所指 編碼 n
  dStk.push(n)			// 將 n 放上堆疊
} end-code compileOnly		// 使 doLit 在高階編譯狀態 才編碼
code ; function () { // 定義 指令 ; ( -- ) 結束 高階指令的定義
  compileCode("ret")			// 編譯 ret 為 高階指令 內碼
  compiling=0				// 高階指令 編譯狀態 結束
  var src=tib.substring(hSrc,iTib)	// 源碼字串
  newWord(hName,hXt,src)		// 以 名稱 內碼起點 原碼字串 定義 高階指令
} end-code compileOnly immediate	// 使 ; 在高階編譯狀態 才編碼 能執行
code + function (){
  var x=dStk.pop(); dStk[dStk.length-1]+=x
} end-code
code $" function () { // 定義 $"  取源碼字串直到 "
  var s=nxtTkn('"')
  if (compiling) compileCode('doLit',s)
  else dStk.push(s)
} end-code immediate
code . function (){
  print(' '+dStk.pop())
} end-code
code cr function (){
  print('\n')
} end-code
code debug function(){
  while(token=nxtTkn()){
    if (z=findWord(token)){
       debugged.push(z)
       print('\nset '+token+' to debugged')
    } else
       showErr('\n'+token+' undefined')
  }
} end-code
code unbug function(){
  while(token=nxtTkn()){ var i
    if (i=debugged.indexOf(token)) {
       debugged=debugged.slice(0,i).concat(debugged.slice(i+1))
       print('\nremove '+token+' from debugged')
    } else
       showErr('\n'+token+' not in debbuged')
  }
} end-code
: task1 9 for 1 $" ," + r@ + . 2000 ms next ;
: task2 4 for 2 $" ," + r@ + . 4000 ms next ;
: action1  1 向右滑入 2500 ms 3 for 1 向左滑入 2500 ms 1 向右滑入 2500 ms next ;
: action2             2500 ms 3 for 1 向右滾動 2500 ms 1 向左滾動 2500 ms next ;
: action3             2500 ms 3 for 1 向下滑入 2500 ms 1 向上滑入 2500 ms next ;
// /////////////////////////////////////////////////////////////////
debug 向上滑入
1,2,3 向右滑入 3000 ms 1,2,3 向左滑入 3000 ms 向右滾動 2 向左滾動 3 向下滑入 3000 ms 2 向右滾動 向左滾動 3 向上滑入
time_bgn start task1 21000 ms start task2 time_end 21000 ms
start action1 action2 action3