<html><head>
<!-- multiTaskJavascriptEforth.html 2012/2/16 ~ 2014/04/08
yapcheahshen@gmail.com samsuanchen@gmail.com ChenHanSunDing@gmail.com -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Multi Task Javascript eForth</title>
	<link type="text/css" rel="stylesheet" href="multiTaskJavascriptEforth.css">
</head><body onload="init()"><center>
	<table><tr><td>
	<center><h3>This Javascript <mrk>eForth VM</mrk> initially has only the word "<mrk>code</mrk>"</h3>
	<input	id="ignoreDef" onchange='ignoreDefChange()' type="checkbox">ignoreTextOf
	<input	id="pattern" size=82 value='code(.+?\n)+?\}\s+end-code.*?\n'><br>
	Enter topic <span id="spn_iTopic">01</span><input id="topic" size=28 onchange='topicChange()' onkeydown='topicSelect()' value=''>
	Enter <mrk>source code</mrk> in the following text area
	<button onclick="saveInput()">saveText</button></center>
	</div> 
	<textarea id="input">code immediate function () {	// 定義 指令 immediate
  lastWord.immediate=1		// 使 最後定義的指令 在高階編譯狀態 能執行
} end-code
code // function () { var n,t	// 定義 指令 // (雙斜線) 忽略源碼字串到 列尾
  iTib += (n= (t=tib.substr(iTib)).indexOf('\n') )>=0 ? n : t.length
} end-code immediate		// 使 雙斜線 指令 在高階編譯狀態 能執行
// // // // // // // // // // // // // // // // // // // // // // // //
//		請 先 讀 此 說 明	R E A D M E   F I R S T
// // // // // // // // // // // // // // // // // // // // // // // //
//   此 符式系統 非常原始, 剛啟動時 只有 符式指令 code, 簡述相關說明如下
// A 此例 先用 code 定義 符式指令 immediate 及 雙斜線, 主要希 雙斜線 用作註解
//   注意! 雙斜線 後必須 空格, 這樣 接下來的源碼字串 才會當作 註解 直到列尾
// B 用 code 所定義的 是所謂 符式低階指令, 以 javascript 匿名 function 描述動作
// C code 語法: 其後是 指令名稱 接下來到 end-code 是 不含參數的 匿名 function
//   符式指令 之間 通常都用 堆疊 dStk 傳遞資訊, 不用參數 傳遞資訊
//   注意! function 依循 javascript 語法 (雙斜線 到 列尾 間字串 已用作註解)
// D 注意! code 之後 若是字串 function, 此 function 並不當作 新指令名稱
//   這時 從 function 到 end-code 前 直接用來 定義 javascript 含名 function
//   依 javascript 語法 也可宣告參數, 這些 function 可被 符式低階指令 呼叫
// E 後續 用 code 所定義 冒號 : 及 分號 ; 倆指令 是特別用來定義 符式高階指令 的
//   冒號指令 接 空格 然後才是 新指令名稱, 之後 就可用已定義 符式指令 描述動作
//   直到 分號指令 為止, 其間包括用 雙斜線 指令 接 空格 直到列尾的字串 當作註解
// F 清空 text area 選點 evalute 然後 按 F5 鍵 可從新恢復 text area 原網頁內容
// G 按 F12 鍵 可進入 javascript 的追蹤除錯視窗, 可到 js 檔尾 dbg 指令設斷點
//   在 text area 程式碼 插入 dbg 指令 點 evalute, 執行到 dbg 即可進行追蹤除錯
// H 下面 debug 指令 讓 源碼隨後指令 執行前先印出 "debugging" (可到 dbg 設斷點)
// // // // // // // // // // // // // // // // // // // // // // // //
code debug function() {	// 定義 指令 debug ( <指令名稱> -- )
  var token=nxtTkn()	// 從 隨後源碼 取 token (以空格區隔的下一個字串)
  var z=findWord(token)	// 取 所對應 指令位址 [vid,wid]
  if (z) {
    if (0>debugged.indexOf(z=z.join())) // 如果 不在 待追蹤指令陣列
      debugged.push(z)			// 將 指令位址 加入 待追蹤指令陣列
    else
      print(z+' already in debugged')	// 已在 待追蹤指令陣列
  } else
      abort('illegal debug '+token)	// 沒有 所對應 符式指令 資訊
} end-code
code find function () { // 定義 指令 find ( <指令名稱> -- 指令位址 )
  dStk.push( findWord( nxtTkn() ) )	// 取 隨後源碼 指令名稱 的 指令位址 放上堆疊
} end-code
code ' function () { // 定義 指令 ' ( <指令名稱> -- 指令位址 )
  var z, t
  var z=findWord(t=nxtTkn())	// 取 隨後源碼 指令名稱 的 指令位址 z
  if (z) dStk.push(z)		// 若找到 z 就放上堆疊
  else abort(t+' not found')	// 否則 就 abort
} end-code
code alias function () { // 定義 指令 alias ( 指令位址 <指令別名> -- )
  var w=zWord(dStk.pop())	// 取 已定義指令 w
  newWord(nxtTkn(),w.xt)	// 定義 隨後源碼 指令別名
  if (w.src)         lastWord.src	 =w.src		// 高階源碼
  if (w.compileOnly) lastWord.compileOnly=w.compileOnly	// 在高階編譯狀態 才執行
  if (w.immediate)   lastWord.immediate	 =w.immediate	// 在高階編譯狀態 能執行
  if (w.words)       lastWord.words	 =w.words	// 詞彙指令陣列
  if (w.dictionary)  lastWord.dictionary =w.dictionary	// 詞彙指令索引
} end-code
code : function () { // 定義 指令 : ( <指令名稱> -- ) 開始 高階指令的定義
  src		= ''			// 高階指令 源碼
  hSrc		= iTib-2		// 高階指令 源碼字串起點
  hName		= nxtTkn()		// 高階指令 名稱
  hXt		= compiledCode.length 	// 高階指令 編碼起點
  compiling	= 1			// 高階指令 編譯狀態 進入
} end-code
code compileOnly function () { // 定義 指令 compileOnly ( -- )
  lastWord.compileOnly=1		// 使 最後定義指令 高階編譯狀態 才編碼
} end-code
code ret function () { // 定義 指令 ret ( -- ) 結束被呼叫的 高階指令
  ip=rStk.pop()		// 從 return stack 取出 ip
} end-code compileOnly	// 使 ret 在高階編譯狀態 才編碼
code doLit function () { // 定義 指令 doLit ( -- n ) 將 隨後編碼 n 放上堆疊
  var n=compiledCode[ip++]	// 取 ip 所指 編碼 n
  dStk.push(n)			// 將 n 放上堆疊
} end-code compileOnly		// 使 doLit 在高階編譯狀態 才編碼
code ; function () { // 定義 指令 ; ( -- ) 結束 高階指令的定義
  compileCode("ret")			// 編譯 ret 為 高階指令 內碼
  compiling=0				// 高階指令 編譯狀態 結束
  var src=tib.substring(hSrc,iTib)	// 源碼字串
  newWord(hName,hXt,src)		// 以 名稱 內碼起點 原碼字串 定義 高階指令
} end-code compileOnly immediate	// 使 ; 在高階編譯狀態 才編碼 能執行
code + function () { // 定義 指令 + ( a b -- a+b ) 加法 可為數字 或 字串
  var x=dStk.pop(); dStk[dStk.length-1]+=x
} end-code
code - function () { // 定義 指令 - ( a b -- a-b ) 減法
  var x=dStk.pop(); dStk[dStk.length-1]-=x
} end-code
code * function () { // 定義 指令 * ( a b -- a*b ) 乘法
  var x=dStk.pop(); dStk[dStk.length-1]*=x
} end-code
code / function () { // 定義 指令 / ( a b -- a/b ) 除法
  var x=dStk.pop(); dStk[dStk.length-1]/=x
} end-code
code % function () { // 定義 指令 % ( a b -- a%b ) 餘數
  var x=dStk.pop(); dStk[dStk.length-1]%=x
} end-code
code . function () { // 定義 指令 . ( n -- ) 列印 n 可為 數字, 字串, 陣列
  print(" "+dStk.pop())
} end-code
code dup function () { // 定義 指令 dup ( n -- n n )
  dStk.push(dStk[dStk.length-1])
} end-code
code .s function () { // 定義 指令 .s ( -- ) 檢視 堆疊數值
  print(' '+(dStk.join(' ')||'empty'))
} end-code
code words function () { // 定義 words 檢視 所有 指令名稱 (可能重複)
  var v=vocs[context[0]]
  print('/n '+v.words.map(	// 從 words 陣列 針對每個指令 w
    function(w){return w?w.name:''}	// 取其 名稱
  ).join(' '))			// 列印
} end-code
words // 檢視 所有 指令名稱
code uniqueWords function () { // 定義 uniqueWords 檢視 所有 指令名稱 (不重複)
  var v=vocs[context[0]], t='/n ', w
  for(w in v.dictionary)	// 從 dictionary 物件 針對每個指令 w
    t+=' '+w			// 採用	空格 區隔
  print(t)			// 列印
} end-code
uniqueWords // 檢視 所有 指令名稱 (不重複)
: sq // 定義 sq 計算 堆頂數值 的平方
  dup	//  複製	堆頂數值
  *	//  相乘
;	//  結束	定義
5 sq . // 列印出 5 平方 ==> 25
' alias alias 同義
' sq 同義 平方
' .  同義 印出
5 平方 印出
: 2sq // 定義 2sq 計算 堆頂數值 平方的 2 倍
  sq	//  計算	堆頂數值 的平方
  2 *	//  取其	2 倍
;	//  結束	定義
3 2sq . // 列印出 3 平方的2倍 ==> 18
' 2sq 同義 平方的2倍
3 平方的2倍 印出
code char function () { // 定義 char 取隨後 token 字串的 起首字符
  var c=nxtTkn().substr(0,1)	// 隨後	token 的 起首字符
  if(compiling)			// 檢視	是否 編譯狀態
    compileCode('doLit',c)	// 若是	編譯狀態 就將 doLit 及 字符 編碼
  else dStk.push(c)		// 否則	就將 字符 放上堆疊
} end-code immediate		// 宣告	char 編譯狀態 能執行
char a .	// 列印	字符 a
: a char a . ;	// 定義	a 列印出 字符 a
a		// 列印	字符 a
code see function () { // 定義 see 檢視 指定名稱 指令 的定義源碼
  var msg		// 輸出	字串
  var name=nxtTkn()	// 隨後	token 當作 指令名稱
  var z=findWord(name)
  if (z) {		// 檢視	記錄 id 的陣列 是否存在
	var v=vocs[z[0]], w=v.words[z[1]] // 取其 word
    if (w.src)		// 檢視	高階定義源碼 是否存在
	msg=':'+w.src	// 若是	輸出字串 用 高階定義源碼
    else
	msg='code '+name// 否則	字串 接 指令名稱
	+' '+w.xt	//	字串 接 低階定義源碼
	+' end-'	//	字串 接 'end-'
	+'code'		//	字串 接 'code'
    if (w.compileOnly)	// 檢視	是否 compileOnly
      msg+=' compileOnly'	// 字串	加接 compileOnly
    if (w.immediate  )	// 檢視	是否 immediate
      msg+=' immediate'		// 字串	加接 immediate
  } else
      msg=name+' undefined'	// 字串	顯示 未定義
  print('/n'+msg)		// 列印	字串
} end-code
see see	// 檢視 指令 see 的定義源碼
see a	// 檢視 指令 a   定義源碼
see 2sq	// 檢視 指令 2sq 的定義源碼
see ;	// 檢視 指令 ;   的定義源碼
code (abort") function () {
  abort(compiledCode[ip++])
} end-code compileOnly
code abort" function () {
  var msg=nxtTkn('"')
  if (compiling) compileCode('(abort")',msg)
  else abort(msg)
} end-code compileOnly immediate
// abort" 1st testing the word abort"
// : x abort" 2nd testing the word abort" ; x
code function xxx (x) { // 定義 javascript function xxx (並非 定義 指令 xxx)
  print(x+' is running')
} end-code
// see xxx	// 檢視 字串 xxx 的定義源碼 ==> undefined
code yyy function () {	// 定義 指令 zzz
  xxx(' yyy')		// 呼叫 javascript function xxx (帶 參數)
} end-code
yyy // 呼叫 javascript function xxx(' yyy') 印出 'yyy is running'
code (do) function () { // ( bgn lmt -- )
  var bgn=dStk.pop()
  rStk.push(dStk.pop()), rStk.push(bgn)
} end-code compileOnly
code (loop) function () {
  var t=rStk.length-1, s=t-1
  if (rStk[s]>++rStk[t]) {
    ip=compiledCode[ip]
    return
  }
  ip++, rStk.pop(), rStk.pop()
} end-code compileOnly
code do function () {
  compileCode('(do)')
  dStk.push(compiledCode.length)
} end-code immediate compileOnly
code loop function () {
  compileCode('(loop)',dStk.pop())
} end-code immediate compileOnly
code r@ function () {
  dStk.push(rStk[rStk.length-1])
} end-code
' r@ alias i
code j function () {
  dStk.push(rStk[rStk.length-3])
} end-code
code (.") function () {
  print(compiledCode[ip++])
} end-code compileOnly
code ." function () {
  compileCode('(.")',nxtTkn('"'))
} end-code compileOnly immediate
code emit function () { // ( charCode -- )
  var p=RegExp(String.fromCharCode(60),g)
  print( String.fromCharCode(dStk.pop()).replace(p,'<') )
} end-code
code cr function () {
  cr()
} end-code
code drop function () { // ( n -- )
  dStk.length--
} end-code
code .r function () { // ( n w -- )
  var w=dStk.pop(), s=dStk.pop().toString(base)
  print('         '.substr(0,w-s.length)+s)
} end-code
: x1 ." 9*9 table using do-loop"
  10 1
  do cr 10 1
     do j i * 3 .r
     loop
  loop
;
x1
code >r function () {
  rStk.push(dStk.pop())
} end-code compileOnly
code r> function () {
  dStk.push(rStk.pop())
} end-code compileOnly
code for function () {
  compileCode('>r'), dStk.push(compiledCode.length)
} end-code compileOnly immediate
code (next) function () {
  var rTop=--rStk[rStk.length-1]
  if (0>rTop) {
    ip++, rStk.length--
    return
  }
  ip=compiledCode[ip]
} end-code compileOnly
code next function () {
  compileCode('(next)',dStk.pop())
} end-code compileOnly immediate
: x2 ." 9*9 table using for-next" 8
  for 9 r@ - cr 8
      for dup 9 r@ - * 3 .r
      next drop
  next
;
x2
code zbranch function () {
  if (dStk.pop()) ip++
  else ip=compiledCode[ip]
} end-code compileOnly
code branch function () {
  ip=compiledCode[ip]
} end-code compileOnly
code if function () {
  compileCode('zbranch')
  dStk.push(compiledCode.length)
  compile(-1)
} end-code compileOnly immediate
code else function () {
  compiledCode[dStk.pop()]=compiledCode.length+2
  compileCode('branch')
  dStk.push(compiledCode.length)
  compile(-1)
} end-code compileOnly immediate
code then function () {
  compiledCode[dStk.pop()]=compiledCode.length
} end-code compileOnly immediate
: x3 dup . ."  is "
  if ." non-"
  then ." zero" ;
0 x3
5 x3
: x4 dup . ."  is "
  if ." non-zero"
  else ." zero"
  then ;
0 x4
5 x4
code begin function () {
  dStk.push(compiledCode.length)
} end-code compileOnly immediate
' ret alias exit
code again function () {
  compileCode('branch',dStk.pop())
} end-code compileOnly immediate
code until function () {
  compileCode('zbranch',dStk.pop())
} end-code compileOnly immediate
code while function () {
  compileCode('zbranch')
  dStk.push(compiledCode.length)
  compile(-1)
} end-code compileOnly immediate
code repeat function () {
  var w=dStk.pop()
  compileCode('branch',dStk.pop())
  compiledCode[w]=compiledCode.length
} end-code compileOnly immediate
' ret alias exit
code 1- function () {
  dStk[dStk.length-1]--
} end-code
code 2- function () {
  dStk[dStk.length-1]-=2
} end-code
code 1+ function () {
  dStk[dStk.length-1]++
} end-code
code 2+ function () {
  dStk[dStk.length-1]+=2
} end-code
code ?dup function () {
  var top=dStk[dStk.length-1]
  if (top)
    dStk.push(top)
} end-code
code changeName function () {
  var v=vocs[current], ws=v.words
  ws[ws.length].name=nxtTkn()
} end-code
code xxx function () {
  var top=dStk.pop()
  dStk[dStk.length-1]=top>dStk[dStk.length-1]
} end-code
: x5 9
  begin ?dup
  while dup . 1-
  repeat ;
x5 // 印出 9 8 7 6 5 4 3 2 1
code $" function () { // 定義 $"  取源碼字串直到 "
  var s=nxtTkn('"')
  if (compiling) compileCode('doLit',s)
  else dStk.push(s)
} end-code
$" abc" $" def" + . // 印出 abcdef
code = function () {
  dStk.push(dStk.pop()===dStk.pop())
} end-code
: x6 9 begin dup . 1- dup -1 = until ;
x6 // 印出 9 8 7 6 5 4 3 2 1 0</textarea><div class="blk"><center>
	Click <button onclick="evaluateInput()">evaluate</button>
	to see the <mrk>result</mrk> in the following output area.
	<input	id="directOut" type="checkbox">directOut
	<input	id="saveWords" type="checkbox">saveWords
	</center></div>
	<pre id="output"></pre>
	<table id="picture"><tr>
	<td width="60%"><img src="multiTaskJavascriptEforth.jpg" width="80%"></td>
	<td width="40%" align="left">ChenHanSunDing@gmail.com<br>右　丁陳漢蓀<br>
	    SamSuanChen@gmail.com<br>中　陳　　爽<br>
		YapCheahShen@gmail.com<br>左　葉 健 欣</td>
	</tr></table></td></tr></table></center>
	<script src="multiTaskJavascriptEforth.js"></script>
	<script>
	'uses strict' 									// check all undefined references
	var inp, out, compiledCode, words, dictionary,x,t	// local variables used
	var topics=(localStorage.getItem('multiTaskJavascriptEforth.topics')||'').split(',')
	var iTopic=parseInt(localStorage.getItem('multiTaskJavascriptEforth.iTopic')||0)
//	var VM = new eForthVM()							// get eforth VM
	var VM = new eForthVM1()							// get eforth VM
	function getTopic(i) {
		return (topics.length>i&&i>=0?topics[i]:'')
	}
	function init() {	// the function exeduted while loading this web page
		output.innerHTML+='init '+Date()
		showTopic(iTopic)								// view the source code
		t=topic.value.trim()
		x=localStorage.getItem('multiTaskJavascriptEforth.'+t) // read previously used source code
		input.value=x
		x=localStorage.getItem('multiTaskJavascriptEforthJson')
		if (x) {
			x=JSON.parse(x)
			compiledCode=VM.setCompiledCode(x.compiledCode)
			dictionary=VM.setDictionary(x.dictionary)
			words=VM.setWords(x.words)
			output.innerHTML+='<ok>This system currently has words:</ok>\n'+
				words.map(function(w){
				return w?w.name:''
			}).join(' ')+'\n'
		}
	}
	function showTopic(i) { var t, x
		spn_iTopic.innerHTML=(i<9?'0':'')+(i+1)
		localStorage.setItem('multiTaskJavascriptEforth.iTopic',i)
		t=getTopic(i)
		if (topic.value!==t) {
			topic.value=t
		}
		loadInput()
		var o=output.innerHTML.replace(/\n+topic ".*?" of length \d+\n$/,'')
		output.innerHTML=o+'\ntopic '+quote(t)+' of length '+input.value.length+'\n'
		output.scrollTop = output.scrollHeight	// scroll up result area
	}
	var KEY_UP=38, KEY_DOWN=40, KEY_CR=13
	function topicSelect() {
		var k=event.keyCode
		if (k===KEY_CR) {
			evaluateInput()
		} else if (k===KEY_UP&&iTopic) {
			saveInput(), showTopic(--iTopic)
		} else if (k===KEY_DOWN&&topics.length>iTopic) {
			saveInput(), showTopic(++iTopic)
		}
	}
	function quote(t){
		return t.match('"')?"'"+t+"'":'"'+t+'"'
	}
	function topicChange() {
		var t=topic.value.trim()
		if (t&&0>topics.indexOf(t)) {
			topics.push(t)
			localStorage.setItem('multiTaskJavascriptEforth.topics',topics)
		}
		var x=localStorage.getItem('multiTaskJavascriptEforth.'+t)||''
		if (x!==input.value) {
			x=input.value
			localStorage.setItem('multiTaskJavascriptEforth.'+t,x)
		}
		var o=output.innerHTML.replace(/topic (\S+) of length (\d+)\n$/,'')
		output.innerHTML=o+'topic '+quote(t)+' of length '+x.length+'\n'
		output.scrollTop = output.scrollHeight	// scroll up result area
	}
	function ignoreDefChange() {
	    if (ignoreDef.checked) {
	    	var p=RegExp(pattern.value,'g')
			input.value=input.value.replace(p,function(m){
				return ''
			})
		}
	}
	function loadInput() { 		// load to text area the source code of given topic
		var i = localStorage.getItem('multiTaskJavascriptEforth.'+topic.value.trim())
		if (input.value !== i)	// if not the same
			input.value   = i	// load source code
		return i
	}
	function saveInput() { var inp = input.value						// get source code
	//	input.scrollTop = input.scrollHeight// scroll up source code area
		var t=topic.value.trim()
		if (localStorage.getItem('multiTaskJavascriptEforth.'+t)!==inp)	// if changed
			localStorage.setItem('multiTaskJavascriptEforth.'+t,inp)		// save source code
		return inp
	}
	function emptyVocs(){
		vocs.length=1, v=vocs[0], v.words.length=2, VM.setVocs('{}')
		console.log('forget all words')
	}
	function evaluateInput() {
		var t, i, inp, json					// the function processing source code
		inp=saveInput()						// save source code
		if (t=topic.value.trim()) {			// if topic not empty
			if ((i=topics.indexOf(t))>=0) {	// if not new topic
				if (inp.trim()) {			// if not empty source code
					showTopic(i), iTopic=i	// show iTopic
				} else {					// delete topic if empty source code
					topcs=topcs.slice(0,i).concat(topcs.slice(i+1))
					localStorage.setItem('multiTaskJavascriptEforth.topics',topics)
					loadTopic(i)
				}
			} else {						// if new topic
				topics.push(t)				// add new topic and save topics
				localStorage.setItem('multiTaskJavascriptEforth.topics',topics)
			}
		} else if (!inp.trim())				// if topic and source code both empty
			emptyVocs()					// forget all Words
		out = ''							// empty output buffer
		output.innerHTML+='eval '+Date()+'\n'		// show current Time
		VM.exec(inp)						// process source code
		if (out) {							// if output buffer not empty
			output.innerHTML += out, out=''	// show output and scroll up
			output.scrollTop = output.scrollHeight
		}
		if (saveWords.checked) {			// if required to save words
			VM.setVocs()
		}
	}
	function type (msg) {							// define type funtion
		out+=msg									// add msg to output buffer
		if (directOut.checked) {
			output.innerHTML += msg					// show msg
			output.scrollTop = output.scrollHeight	// scroll up result area
			out=''
		}
	}
	VM.type=type							// set type being called in VM
	</script>
</body></html>